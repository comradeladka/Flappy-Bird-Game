<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Flappy Bird â€“ Single File</title>
  <style>
    :root{
      --w: 320px;
      --h: 560px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#6dd5fa;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .wrap{
      position:relative;
      width:var(--w);
      height:var(--h);
    }
    canvas{
      width:var(--w);
      height:var(--h);
      border:3px solid #111;
      border-radius:14px;
      background:#87CEEB;
      box-shadow:0 12px 28px rgba(0,0,0,.35);
      display:block;
    }
    .overlay{
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:14px;
      background:rgba(0,0,0,.45);
      color:#fff;
      z-index:5;
      border-radius:14px;
      text-align:center;
      padding:16px;
    }
    .title{
      font-size:28px;
      font-weight:800;
      letter-spacing:.5px;
      text-shadow:0 2px 6px rgba(0,0,0,.5);
    }
    .btn{
      padding:12px 22px;
      font-size:18px;
      font-weight:700;
      background:linear-gradient(#ffd54f,#ffa000);
      border:none;
      border-radius:10px;
      box-shadow:0 6px 14px rgba(0,0,0,.35);
      cursor:pointer;
      transition:transform .12s ease;
    }
    .btn:active{ transform:scale(.97) }
    .meta{opacity:.9}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="320" height="560" aria-label="Flappy Bird Canvas"></canvas>

    <!-- Start Screen -->
    <div id="start" class="overlay">
      <div class="title">Flappy Bird</div>
      <div class="meta">Tap / Click / Press Space to flap</div>
      <button class="btn" onclick="Game.start()">Start</button>
    </div>

    <!-- Game Over Screen -->
    <div id="over" class="overlay" style="display:none">
      <div class="title">Game Over</div>
      <div id="scoreLine" class="meta">Score: 0</div>
      <button class="btn" onclick="Game.restart()">Restart</button>
    </div>
  </div>

  <script>
  // ===== Simple, single-file Flappy Bird (no external images) =====
  const Game = (() => {
    const cvs = document.getElementById('game');
    const ctx = cvs.getContext('2d');

    // DOM overlays
    const startOverlay = document.getElementById('start');
    const overOverlay  = document.getElementById('over');
    const scoreLine    = document.getElementById('scoreLine');

    // World
    const W = cvs.width, H = cvs.height;
    const GROUND_H = 90;
    const SKY_GRAD_TOP = "#6dd5fa";
    const SKY_GRAD_BOTTOM = "#bdeaff";

    // Bird
    const BIRD = {
      x: 64,
      y: 200,
      vx: 0,
      vy: 0,
      w: 34,
      h: 24,
      gravity: 0.45,   // fall speed
      flap: -7.5,      // jump impulse
      maxVy: 10
    };

    // Pipes
    const PIPE = {
      w: 56,
      gap: 140,           // vertical gap
      speed: 2,           // horizontal speed
      spacing: 190        // distance between pipe pairs
    };

    // Game state
    let pipes = [];
    let score = 0;
    let running = false;
    let cloudT = 0;

    // Helpers ------------------------------------------------------
    const randInt = (min, max) => (Math.random() * (max - min + 1) + min) | 0;

    function reset() {
      BIRD.y = 200;
      BIRD.vy = 0;
      score = 0;
      pipes = [];
      // seed first pipes
      let x = W + 80;
      for (let i = 0; i < 4; i++) {
        pipes.push(makePipePair(x));
        x += PIPE.spacing;
      }
    }

    function makePipePair(x) {
      const minTop = 50;
      const maxTop = H - GROUND_H - PIPE.gap - 50;
      const topH = randInt(minTop, maxTop);
      return {
        x,
        top: { y: 0, h: topH },
        bottom: { y: topH + PIPE.gap, h: H - GROUND_H - (topH + PIPE.gap) },
        scored: false
      };
    }

    // Drawing ------------------------------------------------------
    function drawBackground() {
      // Sky gradient
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, SKY_GRAD_TOP);
      g.addColorStop(1, SKY_GRAD_BOTTOM);
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);

      // Parallax clouds (simple circles)
      cloudT += 0.2;
      drawCloud(60 - (cloudT % (W+120)), 90, 18);
      drawCloud(200 - ((cloudT*0.7) % (W+200)), 60, 22);
      drawCloud(340 - ((cloudT*0.5) % (W+340)), 120, 16);

      // Ground
      ctx.fillStyle = "#d9ad7c";
      ctx.fillRect(0, H - GROUND_H, W, GROUND_H);
      // Grass
      ctx.fillStyle = "#79c36a";
      ctx.fillRect(0, H - GROUND_H, W, 14);
      // Ground stripes
      ctx.fillStyle = "rgba(0,0,0,.08)";
      for (let i = 0; i < W; i += 16) {
        ctx.fillRect(i, H - GROUND_H + 18, 10, 4);
      }
    }

    function drawCloud(x, y, r) {
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.arc(x + r*0.9, y, r*1.3, 0, Math.PI*2);
      ctx.arc(x + r*2.0, y, r, 0, Math.PI*2);
      ctx.fill();
    }

    function drawPipes() {
      for (const p of pipes) {
        // Cylindrical pipe gradient (3D feel)
        const grad = ctx.createLinearGradient(p.x, 0, p.x + PIPE.w, 0);
        grad.addColorStop(0, "#2ecc71");
        grad.addColorStop(0.5, "#27ae60");
        grad.addColorStop(1, "#1e8449");
        ctx.fillStyle = grad;

        // Top pipe
        ctx.fillRect(p.x, p.top.y, PIPE.w, p.top.h);
        // Rim
        ctx.fillStyle = "rgba(0,0,0,.25)";
        ctx.fillRect(p.x, p.top.h - 5, PIPE.w, 5);

        // Bottom pipe
        ctx.fillStyle = grad;
        ctx.fillRect(p.x, p.bottom.y, PIPE.w, p.bottom.h);
        // Rim
        ctx.fillStyle = "rgba(0,0,0,.25)";
        ctx.fillRect(p.x, p.bottom.y, PIPE.w, 5);
      }
    }

    function drawBird() {
      // Body (ellipse with radial gradient)
      const cx = BIRD.x + BIRD.w/2, cy = BIRD.y + BIRD.h/2;
      const rg = ctx.createRadialGradient(cx-4, cy-4, 4, cx, cy, 20);
      rg.addColorStop(0, "#ffe066");
      rg.addColorStop(1, "#ff9800");
      ctx.fillStyle = rg;
      ctx.beginPath();
      ctx.ellipse(cx, cy, BIRD.w/2, BIRD.h/2, 0, 0, Math.PI*2);
      ctx.fill();

      // Eye
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(BIRD.x + BIRD.w*0.72, BIRD.y + BIRD.h*0.35, 4, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "#111";
      ctx.beginPath();
      ctx.arc(BIRD.x + BIRD.w*0.72, BIRD.y + BIRD.h*0.35, 2, 0, Math.PI*2);
      ctx.fill();

      // Beak
      ctx.fillStyle = "#ffb74d";
      ctx.beginPath();
      ctx.moveTo(BIRD.x + BIRD.w, cy - 2);
      ctx.lineTo(BIRD.x + BIRD.w + 10, cy);
      ctx.lineTo(BIRD.x + BIRD.w, cy + 2);
      ctx.closePath();
      ctx.fill();

      // Shadow under bird
      ctx.fillStyle = "rgba(0,0,0,.15)";
      ctx.beginPath();
      ctx.ellipse(BIRD.x + BIRD.w/2, H - GROUND_H + 16, BIRD.w/2.3, 6, 0, 0, Math.PI*2);
      ctx.fill();
    }

    function drawScore() {
      ctx.fillStyle = "rgba(0,0,0,.75)";
      ctx.font = "bold 22px system-ui, Arial, sans-serif";
      ctx.fillText("Score: " + score, 10, 28);
    }

    // Physics & Logic ---------------------------------------------
    function update() {
      // Bird physics
      BIRD.vy = Math.min(BIRD.vy + BIRD.gravity, BIRD.maxVy);
      BIRD.y += BIRD.vy;

      // Ground / ceiling
      if (BIRD.y + BIRD.h >= H - GROUND_H) return gameOver();
      if (BIRD.y <= 0) { BIRD.y = 0; BIRD.vy = 0; }

      // Pipes motion
      for (const p of pipes) {
        p.x -= PIPE.speed;

        // Score when bird fully passes a pipe pair
        if (!p.scored && p.x + PIPE.w < BIRD.x) {
          p.scored = true;
          score++;
        }

        // Collision
        const birdLeft = BIRD.x, birdRight = BIRD.x + BIRD.w;
        const birdTop = BIRD.y, birdBottom = BIRD.y + BIRD.h;

        const withinX = birdRight > p.x && birdLeft < p.x + PIPE.w;
        const hitTop   = birdTop < p.top.h;
        const hitBottom= birdBottom > p.bottom.y;

        if (withinX && (hitTop || hitBottom)) return gameOver();
      }

      // Recycle pipes / add new
      if (pipes.length && pipes[0].x + PIPE.w < -2) pipes.shift();
      const last = pipes[pipes.length - 1];
      if (last && last.x < W - PIPE.spacing) {
        pipes.push(makePipePair(W + 20));
      }
    }

    // Main loop ----------------------------------------------------
    function loop() {
      if (!running) return;
      // Draw order
      drawBackground();
      drawPipes();
      drawBird();
      drawScore();

      update();
      requestAnimationFrame(loop);
    }

    // Controls -----------------------------------------------------
    function flap() {
      if (!running) return;
      BIRD.vy = BIRD.flap;
    }

    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (!running) return;
        flap();
      }
    });

    // Click / touch to flap
    ['click','touchstart'].forEach(ev => {
      cvs.addEventListener(ev, (e) => {
        e.preventDefault();
        flap();
      }, {passive:false});
    });

    // Public API ---------------------------------------------------
    function start() {
      startOverlay.style.display = 'none';
      overOverlay.style.display = 'none';
      running = true;
      reset();
      loop();
    }

    function gameOver() {
      running = false;
      scoreLine.textContent = "Score: " + score;
      overOverlay.style.display = 'flex';
    }

    function restart() { start(); }

    // expose for buttons
    return { start, restart };
  })();

  // also allow Space to start from Start screen
  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      const startEl = document.getElementById('start');
      if (startEl && startEl.style.display !== 'none') {
        e.preventDefault();
        Game.start();
      }
    }
  });
  </script>
</body>
</html>
